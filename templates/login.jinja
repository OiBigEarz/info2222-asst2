<!-- 
    Login page, user is redirected here when the user clicks on Login.
-->

{% extends 'base.jinja' %}

{% block content %} 
    <h1>Login</h1>
    <p>Username</p>
    <input id="username"/>
    <p>Password</p>
    <input id="password"  type="password"/>
    <button onclick="login()">Login</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
    <script>

        // basically checks if the server returns an Error message instead of a URL
        // this is a pretty terrible way of handling error generated by the server, but it works...
        function isValidURL(string) {
            if (string.length == 0) {
                return false;
            }
            if (string[0] == "/") {
                return true;
            }
            return false;
        }

        // login function to well login...
        async function login() {
            let username = $("#username").val();
            let password = $("#password").val();
            let hashedPassword = CryptoJS.SHA256(password).toString(); // Hashing the password
            // this fancy syntax is part of the Jinja syntax
            // login_user is a Python function, this gets the URL that calls that Python function
            // you know the one with the:
            // app.route("/login/user", methods=["POST"])
            // login_user()
            // so... "{{ url_for('login_user')}}" 
            // gives us -> "http://blabla/login/user"


            // axios post is a fancy way of posting a request to the server,
            // we pass in the username and password here
            // Step 1: Fetch salt for the username from the server
            try {
                let saltResponse = await axios.get("{{ url_for('get_salt', username='PLACEHOLDER') }}".replace('PLACEHOLDER', encodeURIComponent(username)));

                if (!saltResponse.data.salt) {
                    throw new Error("Salt not found for the user");
                }
                let saltBase64 = saltResponse.data.salt;
                let salt = Uint8Array.from(atob(saltBase64), c => c.charCodeAt(0));

                // Step 2: Derive the encryption key using the password and salt
                const key = await deriveKey(password, salt);

                // Continue with login process
                try {
                    let response = await axios.post("{{ url_for('login_user') }}", {
                        username: username,
                        password: hashedPassword
                    });

                    if (response.data.login) {
                        // Store the key in sessionStorage or continue to use it directly in memory
                        sessionStorage.setItem("key", btoa(String.fromCharCode(...new Uint8Array(await crypto.subtle.exportKey("raw", key)))));

                        window.location.href = '/home';  // Redirect on successful login
                    } else {
                        alert("Login failed: " + response.data.msg);
                    }
                } catch (error) {
                    console.error('Login error:', error);
                    alert('Login error: ' + (error.response && error.response.data ? error.response.data.msg : 'Server error'));
                }

            } catch (error) {
                console.error('Error fetching salt:', error);
                alert('Login error: Could not fetch salt for key derivation');
            }
        }

        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw",
                encoder.encode(password),
                "PBKDF2",
                false,
                ["deriveBits", "deriveKey"]
            );
            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,  // Whether the key is extractable (i.e., can be exported out of the crypto context)
                ["encrypt", "decrypt"]
            );
        }

    </script>
{% endblock %}
